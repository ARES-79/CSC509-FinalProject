package app.View;

import java.awt.Color;
import java.awt.Font;
import java.awt.FontMetrics;
import java.awt.Graphics;
import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;
import java.util.Deque;
import java.util.List;

import javax.swing.JPanel;
import javax.swing.border.MatteBorder;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import app.Data.Highlight;
import app.Model.Blackboard;

/**
 * The {@code DrawPanel} class is a custom {@link JPanel} that visually
 * represents circles received from PropertyChangeEvents. Each circle is drawn
 * with its
 * respective color, and an outline is added around each circle.
 * <p>
 * This panel is used as part of a graphical interface to display real-time
 * visualizations of the circles generated by the system. It ensures that each
 * circle is
 * displayed with its fill color and a black border.
 * <p>
 * This class also handles rendering and updating of highlights based on the
 * processed data received through property changes.
 *
 * Code Metrics:
 * - Number of Classes: 1 (DrawPanel)
 * - Number of Methods: 6
 * - Lines of Code (LOC): 87 (including comments and blank lines)
 * - Cyclomatic Complexity: 3 (based on method complexity: simple methods, plus
 * conditional logic in `propertyChange`)
 * - Number of Conditional Branches: 6 (includes `if` statements and loops for
 * drawing highlights)
 *
 * @author Andrew Estrada
 * @author Sean Sponsler
 * @author Xiuyuan Qiu
 * @version 1.0
 */
public class DrawPanel extends JPanel implements PropertyChangeListener {

   private final Logger log = LoggerFactory.getLogger(DrawPanel.class);
   private final Deque<List<Highlight>> globalHighlightList = Blackboard.getInstance().getHighlightCollections();
   private final List<Highlight> highlightList = Blackboard.getInstance().getHighlightList();

   private final String paragraph = """
         Lorem ipsum odor amet, consectetuer adipiscing elit. Eu diam luctus semper montes sodales. Sed nostra dignissim venenatis ut ullamcorper platea sagittis.
         Nunc venenatis dolor turpis duis facilisi. Per montes habitant felis efficitur pretium placerat enim.
         Montes per montes elit facilisi feugiat. Maecenas duis torquent enim velit urna dignissim.
         Quisque quisque justo scelerisque eget potenti in eleifend taciti ipsum. Quisque congue felis pharetra, leo ipsum netus?
         Fusce amet sollicitudin eleifend habitant molestie velit. Placerat lobortis maecenas donec et interdum nascetur commodo.
         Lacus dis venenatis tristique eget auctor quisque. Montes erat nulla quam mus curabitur erat gravida.
         Venenatis sem potenti fusce iaculis sed felis condimentum purus. Iaculis ipsum curabitur gravida penatibus lorem efficitur leo fusce.
         Pulvinar efficitur vitae odio urna pellentesque; litora ad mollis.""" //
   ;
   private final int lineHeight = 100;
   private final int xOffset = 50; // Offsets for text
   private final int yOffset = 50;

   /**
    * Constructor for the {@code DrawPanel}. Initializes the panel and sets up
    * property change listener for processing highlight data.
    */
   public DrawPanel() {
      setBackground(Color.WHITE);
      setBorder(new MatteBorder(3, 3, 3, 3, Color.BLACK));
      Blackboard.getInstance().addPropertyChangeListener(Blackboard.PROPERTY_NAME_VIEW_DATA, this);
   }

   /**
    * Paints the component, wrapping the paragraph text and rendering the
    * highlights as they are received through property changes.
    * 
    * @param g The Graphics object used for drawing.
    */
   @Override
   protected void paintComponent(Graphics g) {
      super.paintComponent(g);
      Font font = new Font("Arial", Font.PLAIN, 14);
      g.setFont(font);

      // Use FontMetrics to measure text
      FontMetrics metrics = g.getFontMetrics(font);

      // Wrap the paragraph into multiple lines
      String[] lines = wrapText(paragraph, metrics, getWidth() - 2 * xOffset);

      // Draw each line of text
      int currentY = yOffset;
      for (String line : lines) {
         g.drawString(line, xOffset, currentY);
         // Move to the next line
         currentY += lineHeight;
      }

      // Draw all highlights
      for (List<Highlight> localHighlightList : globalHighlightList) {
         for (Highlight highlight : localHighlightList) {
            highlight.drawHighlight(g);
         }
      }
      g.setColor(Color.BLACK);
   }

   /**
    * Wraps the input text into multiple lines based on the available width.
    * 
    * @param text     The input text to wrap.
    * @param metrics  The font metrics used to calculate string width.
    * @param maxWidth The maximum width available for each line.
    * @return A string array containing wrapped lines of text.
    */
   private String[] wrapText(String text, FontMetrics metrics, int maxWidth) {
      String[] words = text.split(" ");
      StringBuilder currentLine = new StringBuilder();
      java.util.List<String> lines = new java.util.ArrayList<>();

      for (String word : words) {
         if (metrics.stringWidth(currentLine.toString() + word) <= maxWidth) {
            currentLine.append(word).append(" ");
         } else {
            lines.add(currentLine.toString().trim());
            currentLine.setLength(0); // Reset the current line
            currentLine.append(word).append(" ");
         }
      }

      // Add the last line
      if (currentLine.length() > 0) {
         lines.add(currentLine.toString().trim());
      }

      return lines.toArray(new String[0]);
   }

   /**
    * Handles property change events triggered by new highlight data. It processes
    * either a single highlight or a list of highlights and updates the drawing
    * accordingly.
    * 
    * @param evt The property change event containing the new highlight data.
    */
   @Override
   public void propertyChange(PropertyChangeEvent evt) {
      if (Blackboard.PROPERTY_NAME_VIEW_DATA.equals(evt.getPropertyName())) {
         if (evt.getNewValue() instanceof Highlight) {
            // Handle single Highlight
            Highlight newHighlight = (Highlight) evt.getNewValue();
            this.highlightList.add(newHighlight);
            repaint();
         } else if (evt.getNewValue() instanceof List<?>) {
            List<?> newList = (List<?>) evt.getNewValue();
            if (!newList.isEmpty()) {
               if (newList.get(0) instanceof Highlight) {
                  // Handle list of Highlights
                  List<Highlight> newHighlightList = (List<Highlight>) newList;
                  this.globalHighlightList.add(newHighlightList);
                  repaint();
               } else {
                  log.warn("Unexpected payload in PropertyChangeEvent: {}", evt.getNewValue());
               }
            } else {
               log.warn("Unexpected payload in PropertyChangeEvent: {}", evt.getNewValue());
            }
         } else {
            log.warn("Unexpected payload in PropertyChangeEvent: {}", evt.getNewValue());
         }
      }
   }
}
